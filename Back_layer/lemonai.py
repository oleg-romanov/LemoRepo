# -*- coding: utf-8 -*-
"""LemonAI.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eMZ43m3Osw9sxZvYTCCvHe-XHyAi_Klo
"""

import os
import zipfile
import requests
import numpy as np
import cv2
from pycocotools.coco import COCO

# @title
repo_url1 = 'https://github.com/dish0nest/Server-Client/raw/main/Dataset.zip'
zip_file_path1 = '/content/Dataset.zip'

# @title
repo_url2 = 'https://github.com/softwaremill/lemon-dataset/raw/master/data/lemon-dataset.zip'
zip_file_path2 = '/content/lemons.zip'

# @title
response = requests.get(repo_url1)
with open(zip_file_path1, 'wb') as f:
    f.write(response.content)

# @title
response = requests.get(repo_url2)
with open(zip_file_path2, 'wb') as f:
    f.write(response.content)

# @title
with zipfile.ZipFile(zip_file_path1, 'r') as zip_ref:
    zip_ref.extractall('/content/')

# @title
with zipfile.ZipFile(zip_file_path2, 'r') as zip_ref:
    zip_ref.extractall('/content/')

# @title
DataPath = "/content/Dataset"
DataPath2 = '/content/lemon-dataset'

# @title
coco = COCO(f'{DataPath2}/annotations/instances_default.json')
cats = coco.cats
print(cats)

"""Разделяет аннотированные изображения лимонов на основе списка аннотаций, а также удаляет те изображения, на которых виден остаток от стебля. Возвращает кортеж списков: лимоны плохого качества и хорошего качества"""

# @title
def sort_lemons(coco, tags: list) -> tuple:

    all_lemon_ids = coco.getImgIds()
    pedicel_ids = coco.getImgIds(catIds=[9])
    non_pedicel_ids = [i for i in all_lemon_ids if i not in pedicel_ids]
    temp_list = []
    bad_ids = []
    good_ids = []
    for tag in tags:
        arr = coco.getImgIds(catIds=[tag])
        for i in arr:
            if i in non_pedicel_ids:
                temp_list.append(i)

    [bad_ids.append(i) for i in temp_list if i not in bad_ids]
    [good_ids.append(i) for i in non_pedicel_ids if i not in bad_ids]
    bad_lemons = coco.loadImgs(ids=bad_ids)
    good_lemons = coco.loadImgs(ids=good_ids)
    return bad_lemons, good_lemons

# @title
my_sort = sort_lemons(coco=coco, tags=[2,3,4,5])

"""Перемещение отсортированных изображений лимонов из второго датасета в соответсвующие папки первого датасета  """

# @title
import shutil

def move_sorted_images(sort: tuple):

    for i in sort[0]:
        file_ext = i['file_name']
        image_file = f'{DataPath2}/{file_ext}'
        shutil.move(image_file, f'{DataPath}/bad_quality')
    for i in sort[1]:
        file_ext = i['file_name']
        image_file = f'{DataPath2}/{file_ext}'
        shutil.move(image_file, f'{DataPath}/good_quality')

# @title
my_move = move_sorted_images(sort=my_sort)

"""Удаляем папку с одним задним фоном и папку второго датасета"""

# @title
shutil.rmtree(DataPath2)
shutil.rmtree(f'{DataPath}/empty_background/')

"""Получаем библиотеку для удаления заднего фона на изображениях"""

# @title
!pip install rembg

# @title
BadQualityPath = f"{DataPath}/bad_quality"
GoodQualityPath = f"{DataPath}/good_quality"
os.makedirs(f"{DataPath}/bad_quality_processed")
os.makedirs(f"{DataPath}/good_quality_processed")
BadQualityProcessed = f"{DataPath}/bad_quality_processed"
GoodQualityProcessed = f"{DataPath}/good_quality_processed"

"""Удаляем зкадний фон на изображениях хороших лимонов"""

# @title
from rembg import remove
from PIL import Image
import matplotlib.pyplot as plt


good_quality_files = os.listdir(GoodQualityPath)
for index, my_file in enumerate(good_quality_files):
    image = Image.open(f'{GoodQualityPath}/{my_file}')
    removed = remove(image)
    imageBox = removed.getbbox()
    cropped = removed.crop(imageBox)
    cropped.save(f'{GoodQualityProcessed}/{index}.png')

"""Удаляем зкадний фон на изображениях плохих лимонов"""

# @title
bad_quality_files = os.listdir(BadQualityPath)
for index, my_file in enumerate(bad_quality_files):
    image = Image.open(f'{BadQualityPath}/{my_file}')
    removed = remove(image)
    imageBox = removed.getbbox()
    cropped = removed.crop(imageBox)
    cropped.save(f'{BadQualityProcessed}/{index}.png')

# @title
shutil.rmtree(f'{DataPath}/bad_quality/')
shutil.rmtree(f'{DataPath}/good_quality/')
os.rename(f'{DataPath}/bad_quality_processed/', f'{DataPath}/bad_quality/')
os.rename(f'{DataPath}/good_quality_processed/', f'{DataPath}/good_quality/')

# @title
import random

# @title
my_data_dir = '/content/lemon_dataset'
train_path = my_data_dir + '/train'
val_path = my_data_dir + '/validation'
test_path = my_data_dir + '/test'

# @title
def split_train_validation_test_images(my_data_dir: str, train_set_ratio:
                                       float, validation_set_ratio: float,
                                       test_set_ratio: float):

    labels = os.listdir(my_data_dir)
    if 'test' in labels:
        pass
    else:
        for folder in ['train', 'validation', 'test']:
            for label in labels:
                os.makedirs(name=my_data_dir + '/' + folder + '/' + label)

        for label in labels:
            files = os.listdir(my_data_dir + '/' + label)
            random.shuffle(files)

            train_set_files_qty = int(len(files) * train_set_ratio)
            validation_set_files_qty = int(len(files) * validation_set_ratio)

            count = 1
            for file_name in files:
                if count <= train_set_files_qty:
                    shutil.move(my_data_dir + '/' + label + '/' + file_name,
                                my_data_dir + '/train/' + label + '/'
                                + file_name)

                elif count <= (train_set_files_qty + validation_set_files_qty):
                    shutil.move(my_data_dir + '/' + label + '/' + file_name,
                                my_data_dir + '/validation/' + label + '/'
                                + file_name)

                else:
                    shutil.move(my_data_dir + '/' + label + '/' + file_name,
                                my_data_dir + '/test/' + label + '/'
                                + file_name)

                count += 1

            os.rmdir(my_data_dir + '/' + label)

# @title
split_train_validation_test_images(my_data_dir,
                                   train_set_ratio=0.7,
                                   validation_set_ratio=0.2,
                                   test_set_ratio=0.1)

from google.colab import drive
drive.mount('/content/drive')

zip_file_path = '/content/drive/MyDrive/Lemon AI/lemon_dataset_final.zip'
with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
    zip_ref.extractall('/content/')

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
sns.set()
from PIL import Image
from sklearn.model_selection import train_test_split

root="/content/lemon_dataset_final"

categories=os.listdir(root)
categories

"""Собираем категории из датасета"""

images = []
labels = []
for category in categories:
    directory = root + '/' + category + '/'
    for image_file in os.listdir(directory):
        images.append(directory + image_file)
        labels.append(category)

images = pd.Series(images, name="Image")
labels = pd.Series(labels, name="Quality")

data=pd.concat([images,labels], axis=1)
data.head()

data=data.sample(frac=1).reset_index(drop = True)
data.head()

fig, axes = plt.subplots(3, 4, figsize=(15, 7))

for ax in axes.flat:
    i = np.random.randint(0, data.shape[0])
    ax.imshow(Image.open(data.loc[i, "Image"]))
    ax.grid(False)

plt.tight_layout()
plt.show()

dev, held_out =train_test_split(
    data,
    train_size=0.9,
    shuffle=True,
    random_state=42)

print(dev.shape)
print(held_out.shape)

import keras
from keras.preprocessing import image

"""Аугмуентируем изображения"""

dev_generator = image.ImageDataGenerator(
    rescale=1./255,
    horizontal_flip=True,
    rotation_range=40,
    width_shift_range=0.2,
    height_shift_range=0.2,
    shear_range=0.2,
    zoom_range=0.2,
    validation_split=0.2
)

held_generator = image.ImageDataGenerator(rescale=1./255)

train_images = dev_generator.flow_from_dataframe(
    dataframe=dev,
    x_col='Image',
    y_col='Quality',
    target_size=(255, 255),
    color_mode='rgb',
    class_mode='categorical',
    batch_size=32,
    shuffle=True,
    seed=42,
    subset='training'
)

val_images = dev_generator.flow_from_dataframe(
    dataframe=dev,
    x_col='Image',
    y_col='Quality',
    target_size=(255, 255),
    color_mode='rgb',
    class_mode='categorical',
    batch_size=32,
    shuffle=True,
    seed=42,
    subset='validation'
)

held_images = held_generator.flow_from_dataframe(
    dataframe=held_out,
    x_col='Image',
    y_col='Quality',
    target_size=(255, 255),
    color_mode='rgb',
    class_mode='categorical',
    batch_size=32,
    shuffle=False
)

labels = train_images.class_indices
labels

"""Создаем нейронную сеть и обучаем ее

"""

import matplotlib.pyplot as plt

import keras,os
from keras.models import Sequential
from keras.layers import Dense, Conv2D, MaxPool2D , Flatten, Dropout
from keras.preprocessing.image import ImageDataGenerator
import numpy as np
from keras.callbacks import EarlyStopping
from keras.optimizers import RMSprop

model = Sequential()
model.add(Conv2D(input_shape=(255,255,3),filters=64,kernel_size=(3,3),padding="same", activation="relu"))
model.add(Conv2D(filters=64,kernel_size=(3,3),padding="same", activation="relu"))
model.add(MaxPool2D(pool_size=(2,2),strides=(2,2)))
model.add(Conv2D(filters=128, kernel_size=(3,3), padding="same", activation="relu"))
model.add(Conv2D(filters=128, kernel_size=(3,3), padding="same", activation="relu"))
model.add(MaxPool2D(pool_size=(2,2),strides=(2,2)))
model.add(Conv2D(filters=256, kernel_size=(3,3), padding="same", activation="relu"))
model.add(Conv2D(filters=256, kernel_size=(3,3), padding="same", activation="relu"))
model.add(Conv2D(filters=256, kernel_size=(3,3), padding="same", activation="relu"))
model.add(MaxPool2D(pool_size=(2,2),strides=(2,2)))
model.add(Conv2D(filters=512, kernel_size=(3,3), padding="same", activation="relu"))
model.add(Conv2D(filters=512, kernel_size=(3,3), padding="same", activation="relu"))
model.add(Conv2D(filters=512, kernel_size=(3,3), padding="same", activation="relu"))
model.add(MaxPool2D(pool_size=(2,2),strides=(2,2)))
model.add(Conv2D(filters=512, kernel_size=(3,3), padding="same", activation="relu"))
model.add(Conv2D(filters=512, kernel_size=(3,3), padding="same", activation="relu"))
model.add(Conv2D(filters=512, kernel_size=(3,3), padding="same", activation="relu"))
model.add(MaxPool2D(pool_size=(2,2),strides=(2,2)))
model.add(Dense(units=4096,activation="relu"))
model.add(Dense(units=4096,activation="relu"))
model.add(Flatten())
model.add(Dense(units=256, activation='relu'))
model.add(Dropout(0.5))
model.add(Dense(units=3, activation='softmax'))

optimizer = RMSprop(learning_rate=0.0001)
model.compile(optimizer=optimizer, loss='categorical_crossentropy', metrics=['accuracy'])

model.summary()

early_stopping = EarlyStopping(monitor='val_loss', patience=4, restore_best_weights=True)

history = model.fit(train_images, validation_data=val_images,epochs=200, callbacks=[early_stopping])

model.save('/content/outputs/lemon_quality_model2.h5')

model.save('/content/drive/MyDrive/Lemon AI/lemon_quality_with_green_new_dataset12121.h5')

from keras.models import load_model
model = load_model('/content/drive/MyDrive/LemonAI/lemon_quality_with_green.h5')

prediction=model.predict(held_images)

prediction=np.argmax(prediction, axis=1)
prediction.shape

labels = train_images.class_indices
labels = {v: k for k, v in labels.items()}

y_prediction = [labels.get(k) for k in prediction]
y_test = held_out["Quality"].values

from sklearn.metrics import accuracy_score, classification_report
print(classification_report(y_test, y_prediction))

held_out.reset_index(drop=True, inplace=True)
held_out.head()

"""Получаем случайные изорбражения из тестовой выборки"""

random_index = np.random.randint(0, held_out.shape[0])
image_path = held_out.loc[random_index, "Image"]
predicted_label = y_prediction[random_index]

fig, axes = plt.subplots(3, 4, figsize=(15, 10))

for i, ax in enumerate(axes.flatten()):
    random_index = np.random.randint(0, held_out.shape[0])
    image_path = held_out.loc[random_index, "Image"]
    predicted_label = y_prediction[random_index]

    image = Image.open(image_path)
    ax.imshow(image)
    ax.axis('off')
    ax.set_title(predicted_label)

plt.tight_layout()
plt.show()